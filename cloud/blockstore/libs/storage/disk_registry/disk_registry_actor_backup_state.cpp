#include "disk_registry_actor.h"

namespace NCloud::NBlockStore::NStorage {

using namespace NActors;

using namespace NKikimr;
using namespace NKikimr::NTabletFlatExecutor;

////////////////////////////////////////////////////////////////////////////////

void TDiskRegistryActor::HandleBackupDiskRegistryState(
    const TEvDiskRegistry::TEvBackupDiskRegistryStateRequest::TPtr& ev,
    const TActorContext& ctx)
{
    BLOCKSTORE_DISK_REGISTRY_COUNTER(BackupDiskRegistryState);

    const auto* msg = ev->Get();

    LOG_INFO(
        ctx,
        TBlockStoreComponents::DISK_REGISTRY,
        "%s Received BackupDiskRegistryState request: %s %s",
        LogTitle.GetWithTime().c_str(),
        msg->Record.ShortDebugString().c_str(),
        TransactionTimeTracker.GetInflightInfo(GetCycleCount()).c_str());
    
    NProto::TBackupDiskRegistryStateResponse record;
    if (msg->Record.GetSource() == NProto::BACKUP_DISK_REGISTRY_STATE_SOURCE_RAM) {

        *record.MutableBackupFilePath() =
            msg->Record.GetBackupFilePath();
        *record.MutableRamBackup() =
            State->BackupState();
        record.MutableRamBackup()->MutableConfig()
            ->SetWritableState(CurrentState != STATE_READ_ONLY);

        auto response = std::make_unique<
            TEvDiskRegistry::TEvBackupDiskRegistryStateResponse>();
        response->Record = std::move(record);
        NCloud::Reply(ctx, *ev, std::move(response));
        return;
    }

    auto requestInfo = CreateRequestInfo(
        ev->Sender,
        ev->Cookie,
        msg->CallContext);

    ExecuteTx<TBackupDiskRegistryState>(
        ctx,
        std::move(requestInfo),
        msg->Record.GetBackupFilePath(),
        msg->Record.GetSource());
}

////////////////////////////////////////////////////////////////////////////////

bool TDiskRegistryActor::PrepareBackupDiskRegistryState(
    const TActorContext& ctx,
    TTransactionContext& tx,
    TTxDiskRegistry::TBackupDiskRegistryState& args)
{
    Y_UNUSED(ctx);

    if(args.Source == NProto::BACKUP_DISK_REGISTRY_STATE_SOURCE_BOTH)
    {
        args.RamSnapshot = State->BackupState();
    }

    TDiskRegistryDatabase db(tx.DB);
    return LoadState(db, args.Snapshot);
}

void TDiskRegistryActor::ExecuteBackupDiskRegistryState(
    const TActorContext& ctx,
    TTransactionContext& tx,
    TTxDiskRegistry::TBackupDiskRegistryState& args)
{
    Y_UNUSED(ctx);
    Y_UNUSED(args);

    TDiskRegistryDatabase db(tx.DB);
    db.WriteLastBackupTs(TInstant::Now());
}

void TDiskRegistryActor::CompleteBackupDiskRegistryState(
    const TActorContext& ctx,
    TTxDiskRegistry::TBackupDiskRegistryState& args)
{
    auto response = std::make_unique<
        TEvDiskRegistry::TEvBackupDiskRegistryStateResponse>();
    
    if(args.Source == NProto::BACKUP_DISK_REGISTRY_STATE_SOURCE_BOTH)
    {
        *response->Record.MutableRamBackup() = std::move(args.RamSnapshot);
    }

    *response->Record.MutableBackupFilePath() = args.BackupFilePath;

    // if new fields are added to TDiskRegistryStateSnapshot
    // there will be a compilation error.
    auto& [
        config,
        dirtyDevices,
        agents,
        disks,
        placementGroups,
        brokenDisks,
        disksToReallocate,
        diskStateChanges,
        lastDiskStateSeqNo,
        writableState,
        disksToCleanup,
        errorNotifications,
        userNotifications,
        outdatedVolumeConfigs,
        suspendedDevices,
        automaticallyReplacedDevices,
        diskRegistryAgentListParams
    ] = args.Snapshot;

    auto copy = [] (auto& src, auto* dst) {
        dst->Reserve(src.size());
        std::copy(
            std::make_move_iterator(src.begin()),
            std::make_move_iterator(src.end()),
            RepeatedFieldBackInserter(dst)
        );
        src.clear();
    };

    auto transform = [] (auto& src, auto* dst, auto func) {
        dst->Reserve(src.size());
        for (auto& x: src) {
            func(x, *dst->Add());
        }
        src.clear();
    };

    auto& backup = *response->Record.MutableLocalDbBackup();

    for (auto & [uuid, diskId]: dirtyDevices) {
        backup.AddOldDirtyDevices(uuid);

        auto* dd = backup.AddDirtyDevices();
        dd->SetId(uuid);
        dd->SetDiskId(diskId);
    }

    copy(disks, backup.MutableDisks());
    copy(suspendedDevices, backup.MutableSuspendedDevices());

    copy(agents, backup.MutableAgents());

    copy(placementGroups, backup.MutablePlacementGroups());
    copy(disksToReallocate, backup.MutableDisksToNotify());
    copy(disksToCleanup, backup.MutableDisksToCleanup());

    copy(errorNotifications, backup.MutableErrorNotifications());
    copy(userNotifications, backup.MutableUserNotifications());

    copy(outdatedVolumeConfigs, backup.MutableOutdatedVolumeConfigs());

    transform(brokenDisks, backup.MutableBrokenDisks(), [] (auto& src, auto& dst) {
        dst.SetDiskId(src.DiskId);
        dst.SetTsToDestroy(src.TsToDestroy.MicroSeconds());
    });

    transform(diskStateChanges, backup.MutableDiskStateChanges(), [] (auto& src, auto& dst) {
        dst.MutableState()->Swap(&src.State);
        dst.SetSeqNo(src.SeqNo);
    });

    transform(
        automaticallyReplacedDevices,
        backup.MutableAutomaticallyReplacedDevices(),
        [] (auto& src, auto& dst) {
            dst.SetDeviceId(src.DeviceId);
            dst.SetReplacementTs(src.ReplacementTs.MicroSeconds());
        });

    backup.MutableDiskRegistryAgentListParams()->insert(
        diskRegistryAgentListParams.begin(),
        diskRegistryAgentListParams.end());

    backup.MutableConfig()->Swap(&config);
    backup.MutableConfig()->SetLastDiskStateSeqNo(lastDiskStateSeqNo);
    backup.MutableConfig()->SetWritableState(writableState);

    NCloud::Reply(ctx, *args.RequestInfo, std::move(response));
}

}   // namespace NCloud::NBlockStore::NStorage
